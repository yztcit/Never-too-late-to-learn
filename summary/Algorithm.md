##  算法（Algorithm）
> 简要记录《漫画算法》-程序员小灰

在数学领域，算法是用来解决某一问题的思想和公式；
在计算机领域，算法是一系列程序指令，用来解决特定的运算和逻辑问题。

### 第一章 算法概述

算法有优劣，衡量算法的重要标准有两个：**时间复杂度**、**空间复杂度**；
算法应用的场景多种多样，例如：
- 运算，如求超大数的和，求公约数等；
- 查找，如搜索引擎、数据库查询等；
- 排序，如热门商品排序，各种排行等；
- 最优决策，如走迷宫游戏的最佳路线等；
- 面试，面试官通过算法考察程序员对计算机底层知识的了解和衡量逻辑思维能力。

#### 1.1 数据结构

数据结构，data structure，是数据的组织、管理和存储格式，其使用目的是高效地访问和修改数据，是算法的基石。

数据结构的组织方式如下：
*1） 线性结构*
	线性结构是最简单的数据结构，包括*数组*、*链表*、及由它们衍生出的*栈*、*队列*、*哈希表*。
*2） 树*
	树是相对复杂的数据结构，其中代表是*二叉树*，由它又衍生出了二叉堆之类的数据结构。
*3） 图*
	图是更为复杂的数据结构，因为在图中会呈现多对多的关联关系。
*4） 其他数据结构*
	其他数据结构由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等。
	
在解决问题时，不同的算法会选用不同的数据结构。例如排序算法中的堆排序，利用的就是二叉堆这样一种数据结构；再如缓存淘汰算法 LRU（Least Recently Used，最近最少使用），利用的就是特殊数据结构哈希链表。

#### 1.2 时间复杂度

**程序运行时间**的长短和**占用内存空间**的大小，是衡量程序好坏的重要因素。

**基本操作执行次数**：
- 线性，T(n) = n;
- 对数，T(n) = log n;
- 常量，T(n) = n;
- 多项式，T(n) = an^2 + bn; 即 T(n) = n^2;

**渐进时间复杂度**（asymptotic time complexity）:
若存在函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不为零的常数，则称f(n)是T(n)的同量级函数。记作T(n)=O(f(n))，O为算法的渐进时间复杂度，简称时间复杂度。
因为渐进时间复杂度用大写O表示，所以也别称为大O表示法。

推导时间复杂度，有如下几个原则：
- 如果运行时间是常数量级，则用常数1表示；
- 只保留函数中的最高阶项；
- 如果最高阶项存在，则省去最高阶项前面的系数；

当n的取值足够大：
	O(1) < O(logn) < O(n) < O(n^2)

#### 1.3 空间复杂度

简单来说，时间复杂度是执行算法的时间成本，空间复杂度是执行算法的空间成本。

空间复杂度（space complexity），是对一个算法在运行过程中临时占用存储空间大小的量度，它同样用了大O表示法—— S(n)=O(f(n))，其中n为问题的规模，f(n)为算法所占存储空间的函数。

常见空间复杂度有如下几种情形：
1.  常量空间，算法的存储空间大小固定，O(1)；
2.  线性空间，算法分配的存储空间是一个线性集合，如数组，并且集合大小和输入规模n成正比，O(n)；
3.  二维空间，算法分配的存储空间是一个二维数组，O(n^2)；
4.  递归空间，O(n)。虽然递归代码中没有显式的声明变量或集合，但是在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。
	“方法调用栈”包括 **进栈** 和 **出栈** 两个动作。


### 第二章 数据结构基础

#### 2.1 数组
#### 2.1.1 数组的初识
**数组**， array，有限个相同类型元素的有序集合；

*数组在内存中的顺序存储，即占用内存中一块连续的内存空间。*

#### 2.1.2 数组的操作
数组的操作即 增、删、改、查。

1.读取元素，按照下标随机读取，需注意下标不要越界；
2.更新元素，直接利用下标把新值赋值给元素；
3.插入元素，插入元素有三种情况：
	- 尾部插入；
	- 中间插入，其后的元素需向后移动一位；
	- 超范围插入，数组需要扩容。
4.删除元素，和插入动作相反，如果删除的元素在中间，其后的元素需向前移动一位。

#### 2.1.3 数组的优势和劣势
**优势**：数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应的元素；
**劣势**：体现在插入和删除方面。由于数组元素连续紧密的存储在内存中，插入和删除都会导致大量元素被迫移动，影响效率。

总的来说，数组适合的是读操作多，写操作少的场景。


#### 2.2 链表
#### 2.2.1 什么是链表
**链表**，linked list，是一种在物理上非连续、非顺序的数据结构，由若干节点（node）组成。

**单向链表**的每一个节点包括两部分：存放数据的变量data，指向下一个节点的指针next；
第一个节点称为头节点，最后一个节点称为尾节点，尾节点的next指针指向NULL。
只能通过节点指针一级一级查找。

**双向链表**多一个指向前置节点的prev指针，头节点prev指针指向NULL。

数组在内存中的存储方式是顺序存储，链表则是随机存储。
链表采用见缝插针的方式，依靠指正关联，这样可以灵活有效的利用零散的碎片空间。

#### 2.2.2 链表的操作
1.查找节点，从头节点向后逐一查找；
2.更新节点，直接替换旧数据；
3.插入节点，重新关联指针；
4.删除节点，解关联指针。

许多高级语言，如Java，拥有自动垃圾回收机制，所以我们不用刻意去释放被删除的节点，只要没有外部引用指向它们，被删除的节点就是自动回收。

#### 2.2.3 数组和链表的比较
||查找|更新|插入|删除|
|:---:|:---:|:---:|:---:|:---:|
|数组|O(1)|O(1)|O(n)|O(n)|
|链表|O(n)|O(1)|O(1)|O(1)|

可以看出，数组的优势在于能够快速定位元素，适用于读操作多，写操作少的场景；
链表的优势在于能够灵活的进行插入和删除操作，适用于在尾部频繁插入和删除元素。


#### 2.3 栈和队列
#### 2.3.1 物理结构和逻辑结构
常用的数据结构有很多，但大多数都以数组或者链表作为存储方式。数组和链表可以被看作数据存储的**“物理结构”**。

**“逻辑结构”**是抽象的概念，它依赖于物理结构。

逻辑结构：
- 线性结构，如顺序表、栈、队列；

- 非线性结构，如树、图；

物理结构：

- 顺序存储，如数组；

- 链式存储，如链表。

#### 2.3.2 栈

**栈**，stack，是一种线性数据结构，栈中元素只能**先入后出（FILO）**。最早进入的元素存放的位置叫作**栈底（bottom）**，最后进入的元素存放的位置叫作**栈顶（top）**。

- 栈这种数据结构既可以用数组来实现，也可以用链表来实现。

*栈的基本操作*
1. 入栈
    push，就是把新元素放入栈中，只允许从栈顶一侧加入元素；

2. 出栈
    pop，就是把元素从栈中弹出，只有栈顶元素才允许出栈。

#### 2.3.3 队列

类似车辆行驶隧道，**队列**，queue，是一种线性数据结构，不同于栈的先入后出，队列中的元素只能**先入先出（FIFO）**。队列的出口端叫作**队头（front）**，队列的入口端叫作**队尾（rear）**。

- 队列这种数据结构既可以用数组来实现，也可以用链表来实现。
用数组实现时，为了入队操作的方便，把队尾位置规定为最后入队元素的下一个位置。

*队列的基本操作*
1. 入队
    enqueue，把新元素加入队列中，只允许在队尾的位置加入元素；
2. 出队
    dequeue，把元素移出队列，只允许在队头一侧移出元素。

**不断的出队，队头左边的空间失去作用，那队列的容量岂不是越来越小？**
数组实现的队列可以采用**循环队列**的方式来*维持队列容量的恒定*。

> 让队尾指针重新指向数组的首位，实现“循环”，这样不但充分利用了数组的空间，还避免了数组整体移动的麻烦。
> 需注意队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1.

```java
public class MyQueue {
	private int[] array;
	private int front;
	private int rear;
	public MyQueue(int capacity){
		this.array = new int[capacity];
	}
	/**
	 * 入队
	 * @param element 入队的元素
	 */
	public void enQueue(int element) throws Exception {
		if((rear+1) % array.length == front){
			throw new Exception(" 队列已满！");
		}
		array[rear] = element;
		rear =(rear+1) % array.length;
	}
	/**
	 * 出队
	 */
	public int deQueue() throws Exception {
		if(rear == front){
			throw new Exception(" 队列已空！");
		}
		int deQueueElement = array[front];
		front =(front+1) % array.length;
		return deQueueElement;
	}
}
```

#### 2.3.4 栈和队列的应用

1. 栈的应用
    栈的输入顺序和输出顺序相反，所以栈通常用来对“历史”的回溯，也就是逆流而上追溯“历史”；
    例如递归，面包屑导航（浏览器标签页回溯）。
    
2. 队列的应用
    队列的输入顺序和输出顺序相同，所以队列通常用来对“历史”回放，也就是按照“历史”顺序，把“历史”重演一遍；
    例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的；网络爬虫实现网站抓取，也是把待抓取的网站URL存入队列，再按照入队顺序来依次抓取和解析。

3. 双端队列
    deque，把栈和队列的特点结合起来，既可以先入先出，也可以先入后出。
    
4. 优先队列
    谁的优先级最高，谁先出队。它不属于线性数据结构，是基于二叉堆来实现的。

#### 2.4 散列表

> 散列表也叫哈希表，类似于“词典”，关键词和结果存在映射关系，以key、value形式存储，避免遍历，可以提高查询效率。

#### 2.4.1 哈希函数


























































